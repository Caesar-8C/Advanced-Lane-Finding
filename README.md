# Advanced Lane Finding

![intro_image][image9]

The goals of this project are the following:

* Compute the camera calibration matrix and distortion coefficients given a set of chessboard images.
* Apply a distortion correction to raw images.
* Use color transforms, gradients, etc., to create a thresholded binary image.
* Apply a perspective transform to rectify binary image ("birds-eye view").
* Detect lane pixels and fit to find the lane boundary.
* Determine the curvature of the lane and vehicle position with respect to center.
* Warp the detected lane boundaries back onto the original image.
* Output visual display of the lane boundaries and numerical estimation of lane curvature and vehicle position.

[//]: # (Image References)
[image0]: ./output_images/calibration_distorted.jpg
[image1]: ./output_images/calibration_undistorted.jpg
[image2]: ./output_images/original_image.jpg
[image3]: ./output_images/undistorted_image.jpg
[image4]: ./output_images/binary_image.jpg
[image5]: ./output_images/warped_image.jpg
[image6]: ./output_images/detection_SWA_image.jpg
[image7]: ./output_images/detection_APA_image.jpg
[image8]: ./output_images/curvature_formula.jpg
[image9]: ./output_images/resulting_image.jpg
[video1]: ./output_videos/project_video.mp4

## Prerequisites

* python3
* numpy
* glob
* moviepy
* cv2

## Project Dtructure

* main.py: reads the data files and starts up the pipeline

src/:

* detect.py: contains `Detect` class that runs the pipeline. This script
contains functions responsible for choosing the lane finding method,
calculating curvature, assembling the resulting image.
* fitting.py: contains functions responsible for finding lanes
on the warped binary image and fitting polynomials
* utils.py: contains other image processing functions like camera calibration,
thresholding, warping.

## Project Description

### Camera Calibration

Before we do any image processing camera calibration parameters should be
obtained. We start with a bunch of checkerboard pattern images, we extract
intersection coordinates with `cv2.findChessboardCorners()` and find the
calibration parameters with `cv2.calibrateCamera()`, after that we can use
`cv2.undistort()` to undistort the images.

Here is an example of an undistorted checkerboard image:

![checkerboard_distorted][image0]
![checkerboard_undistorted][image1]

### Pipeline Description

We start our pipeline with an image of a road:

![original_image][image2]

### 1. Distortion Correction

Camera parameters obtained in Camera Calibration section are now used
to undistort the image.
Undistorted example:

![undistorted_image][image3]

### 2. Binary Image Generation

Example of binary image:

![binary image][image4]

Binary image was generated by combining 3 thresholded images:
* gradient in x direction
* s channel from hls color space
* l channel from hls color space

By combining gradient and s channel images we get a nice clean binary image
which we can process further. The issue is when there are saturated shadows
on the road. Their saturation values are high and they introduce a lot of
noise to the binary. Lightness channel was used to discard shadowed regions
to get final binary.

`thresh()` function from utils.py performs the color transform,
the thresholding and outputs a binary image.

### 3. Perspective Transform

To proceed with polynomial detections we need to perform a perspective
transform to view the scene from above. `warp()` from utils.py does exactly
that. In it there are 8 points defined: we want to warp 4 source points to
4 destination points. Given an image of a straight lane the source points
are picked on the lines close to a vehicle and far away from it. We now
want those points to form a rectangle, so we choose 2 points on the top of
the image and two on the bottom to form a rectangle.

We now compute the perspective transform with `cv2.getPerspectiveTransform()`
and apply it to the binary image with `cv2.warpPerspective()`.

Here is the result:

![warped_image][image5]

### 4. Sliding Window Line Finding

It is now time to detect the lines on the image. To start off the Sliding
Window approach is used. First, we take a look, where on the bottom of
the image most white pixels are concentrated. We start there, count where
the mean is and slide the window in the direction of the mean. Since
more noise is introduced to the top of the image, windows were made
slightly wider to the top.

After detecting all the points that belong to the lines, we can do the fitting.
`np.polyfit()` was used to fit the second order polynomials to the points.

![SWA][image6]

### 5. Around Poly Line Finding

When analyzing a video, our scene does not transform too fast between the
frames, so we can use data obtained on a previous frame to process the next one.

We start now with a polynomial fit to a previous frame, draw them onto a new
warped binary image, make corridors around them. We now take the inliers to
fit the polynomials to. This way we also ensure that the polynomials won't
jiggle around between the frames.

![APA][image7]

### 6. Curvature and Positioning

Given the second order polynomial we can compute the curvature using
formulas implemented in `getCurvature()` from detect.py:

![formula][image8]

`getShift()` from detect.py calculates the distance between the center of
an image (it is assumed the camera is centered on the car) and the center of
the lane (point between the lines on the bottom of the image).

It is important to remember to convert distances and point coordinates
from pixels to meters.

### 7. Image Assembly

The resulting image is assembled from the original image. On top of it
we draw a green lane which is first drawn onto a warped binary image
and then warped back to original. Finally, in the top left corner
lane curvature and car position shift are written.

Here's how it looks in the end:

![resulting_image][image9]

---

### Video Demo

Video demo from output_videos folder also available on youtube:
https://youtu.be/hQGlgKqA4Mk

---

### Problems

* Lane curvature is not precise due to lack of info about distance
from the car to the end of region of interest. It was approximated
using length of the dashes from the dashed line.

* The approach also suffers from multiple lines (road edge, newer
asphalt, etc.) close to the lane-lines. It could be improved with better
parameter tuning. Another way to distinguish lane-lines from noise lines
would affect the stability nicely.